#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <gsl/gsl_math.h>
#include "riemann_toro.h"
#include "routines.h"

/*#include "defs.h"
#include "tree.h"
#include "constants.h"
#include "auxiliary.h"*/

#define DEBUG_TORO_RIEMANN
int RiemannProblem::riemann( double s, double stl[5], double str[5], double sta[5])
{

	double pm, um;
	double rho_s, p_s, u_s;

	r.rho_L = stl[0];
	r.rho_R = str[0];
	r.u_L   = stl[1];
	r.u_R   = str[1];
	r.p_L   = stl[2];
	r.p_R   = str[2];


	//assume gamma is the same

	r.gamma   = stl[4];

	/*follows p153 of toro*/
	r.g1 = (r.gamma-1.0)/(2.0*r.gamma);
	r.g2 = (r.gamma+1.0)/(2.0*r.gamma);
	r.g3 = 2.0*r.gamma/(r.gamma-1.0);
	r.g4 = 2.0/(r.gamma-1.0);
	r.g5 = 2.0/(r.gamma+1.0);
	r.g6 = (r.gamma-1.0)/(r.gamma+1.0);
	r.g7 = 0.5*(r.gamma-1.0);
	r.g8 = (r.gamma-1.0);

	r.mpa = 1.0;


	r.c_sound_L = sqrt(r.gamma*r.p_L/r.rho_L);
	r.c_sound_R = sqrt(r.gamma*r.p_R/r.rho_R);

	//Check for a vacuum state
	if(r.g4*(r.c_sound_L+r.c_sound_R)<=(r.u_R - r.u_L ))
	{
		printf("Vacuum is generated by data (test).\n");
		printf("Left  p %e rho %e u %e\n",r.p_L,r.rho_L,r.u_L);
		printf("Right p %e rho %e u %e\n",r.p_R,r.rho_R,r.u_R);
		printf("r.gamma %e\n",r.gamma);
		printf("r.g4 %e r.c_sound_L %e r.c_sound_R %e\n",r.g4,r.c_sound_L,r.c_sound_R);
		printf("lu %e\n",r.g4*(r.c_sound_L+r.c_sound_R));
		printf("udiff %e\n",r.u_R - r.u_L);
		printf("exiting...\n");
		//exit(-1);
		return 1;
	}

	//Solve the riemann problem

	star_pu_riemann(&pm,&um);


	//Sample the riemann solution at s = x/t

	sample_riemann(s,pm,um,&rho_s,&u_s,&p_s);

	//printf("HERE\n");
	//fflush(stdout);

	sta[0] = rho_s;
	sta[1] = u_s;
	sta[2] = p_s;
	sta[3] = r.gamma;
	sta[4] = r.gamma;

	if(fabs(sta[1])>0 && fabs(sta[1])<1.0e-30)
		printf("RIEMMAN s %e pm %e um %e rho_s %e u_s %e p_s %e gamma %e\n",s,pm,um,rho_s,u_s,p_s,r.gamma);

//inline void sample_riemann(double pm, double um, double s, double *rho_s, double *u_s, double *p_s, struct RiemannStructure r)
	return 0;
}

void RiemannProblem::star_pu_riemann(double *pget, double *uget)
{
	int i;
	double p;
	double u;

	double change;
	double pstart, pold, udiff;

	double f_l, f_ld, f_r, f_rd;

	double pressure_tolerance = 1.0e-9;
	int nr_iter = 50;

	double u_tol = 1.0e-12;
	double u_A;
	double u_B;

	//find a guess for p*

	pstart = guess_p_riemann();

	//printf("rhoR %e uR %e pR %e rhoL %e uL %e pL %e pstart %e\n",r.rho_R,r.u_R,r.p_R,r.rho_L,r.u_L,r.p_L,pstart);
	//fflush(stdout);

	pold  = pstart;

	udiff = r.u_R - r.u_L;

	//find the pressure
	for(i=1;i<=nr_iter;i++)
	{
		prefun_riemann(&f_l,&f_ld,pold,r.rho_L,r.p_L,r.c_sound_L);
		prefun_riemann(&f_r,&f_rd,pold,r.rho_R,r.p_R,r.c_sound_R);

		p = pold - (f_l + f_r + udiff)/(f_ld + f_rd);

		change = 2.*fabs((p-pold)/(p+pold));

		if(change<=pressure_tolerance)
			break;

		if(p<0)
			p = pressure_tolerance;

		pold = p;

		if(i>nr_iter)
		{
			printf("Error: Divergence in Newton-Raphson iteration.\n");
	
			exit(-1);
			//return 1;
		}
	}

	// compute the velocity in the star region
	if( fabs(f_r-f_l)<u_tol)
	{
		u_A = 0;
	}else{
		u_A = f_r - f_l;
	}

	if( fabs(r.u_L + r.u_R)<u_tol)
	{
		u_B = 0;
	}else{
		u_B = r.u_L + r.u_R;
	}

	u = 0.5*( u_B + u_A);

	*pget = p/r.mpa; //divide by normalization constant
	*uget = u;

	if(fabs(u)>0 && fabs(u)<1.0e-30)
	{
		printf("RIEMMAN star_pu p %e mpa %e pget %e u %e u_L %e u_R %e f_r %e f_L %e\n",p,r.mpa,*pget,u,r.u_L,r.u_R,f_r,f_l);
		printf("RIEMMAN prefun L f_l %e f_ld %e pold %19.18e rho_L %e p_L %19.18e c_s_L %e\n",f_l,f_ld,pold,r.rho_L,r.p_L,r.c_sound_L);
		printf("RIEMMAN prefun R f_r %e f_rd %e pold %19.18e rho_R %e p_R %19.18e c_s_R %e\n",f_r,f_rd,pold,r.rho_R,r.p_R,r.c_sound_R);
	}


	//done!
}
double RiemannProblem::guess_p_riemann(void)
{
	//f_rom Toro, pg 156

	//	Purpose: to provide a guess value for p
	//	PM in the Star Region.  The choice is made
	//	according to adatptive Riemann solver using
	//	the PVRS, TRRS, and TSRS approximate Riemann
	//	solvers.  See Sect 9.5 of Chap 9 of Ref 1.

	double quser = 2.0;

	double cup,ppv;

	double pmin, pmax, qmax;
	double pq,ptl,ptr;
	double gel, ger;
	double u_m,p_m;

	// compute guess p f_rom PVRS Riemann solver

	cup  = 0.25*(r.rho_L + r.rho_R)*(r.c_sound_L + r.c_sound_R);
	ppv  = 0.5* (r.p_L   + r.p_R  ) + 0.5*(r.u_L-r.u_R)*cup;
	ppv  = GSL_MAX_DBL(0, ppv);
	pmin = GSL_MIN_DBL(r.p_L, r.p_R);
	pmax = GSL_MAX_DBL(r.p_L, r.p_R);
	qmax = pmax/pmin;


	if((qmax<=quser)&&(pmin<=ppv)&&(ppv<=pmax))
	{
		//Select the PVRS Riemann Solver
		p_m = ppv;

		//printf("case A qmax %e pmin %e ppv %e pmax %e\n",qmax,pmin,ppv,pmax);

	}else if(ppv<pmin){

		//Select the Two-Rarefraction Riemann Solver
		pq = pow(r.p_L/r.p_R,r.g1);	

		u_m  = (pq*r.u_L/r.c_sound_L + r.u_R/r.c_sound_R + r.g4*(pq-1.))/(pq/r.c_sound_L + 1./r.c_sound_R);
		ptl  = 1. + r.g7*(r.u_L -   u_m)/r.c_sound_L;
		ptr  = 1. + r.g7*(  u_m - r.u_R)/r.c_sound_R;
		p_m  = 0.5*( r.p_L*pow(ptl,r.g3) + r.p_R*pow(ptr,r.g3));	

		//printf("case B qmax %e pmin %e ppv %e pmax %e\n",qmax,pmin,ppv,pmax);
	}else{
		//Select Two-Shock Riemann solver with PVRS as estimate

		gel = sqrt((r.g5/r.rho_L)/(r.g6*r.p_L + ppv));
		ger = sqrt((r.g5/r.rho_R)/(r.g6*r.p_R + ppv));

		p_m = (gel*r.p_L + ger*r.p_R - (r.u_R-r.u_L))/(gel+ger);

		//printf("case C qmax %e pmin %e ppv %e pmax %e\n",qmax,pmin,ppv,pmax);
	}

	//return the guess for the pressure
	return p_m;
	
}

void RiemannProblem::prefun_riemann(double *f, double *fd, double p, double dk, double pk, double ck)
{
	// Purpose: to evaluate the pressure functions 
	// FL and FR in the exact Riemann solver

	double prat = 0;
	double ak   = 0;
	double bk   = 0;
	double qrt  = 0;

	double ptol = 1.0e-12;

	if( fabs(p-pk)<ptol )
	{
		//Rarefaction wave

		*f    = 0;

		*fd   = (1./(dk*ck));

	}else if(p<pk)
	{
		//Rarefaction wave
		
		prat = p/pk;

		*f    = r.g4*ck*(pow(prat,r.g1) - 1);

		*fd   = (1./(dk*ck))*pow(prat,-r.g2);
	}else{

		//Shock wave

		ak  = r.g5/dk;

		bk  = r.g6*pk;

		qrt = sqrt( ak/(bk+p) );

		*f   = (p-pk)*qrt;

		*fd  = (1.0 - 0.5*(p-pk)/(bk+p))*qrt;
	}

	//done!

//RIEMMAN prefun L f_l 0.000000e+00 f_ld 7.745967e-01 pold 1.000000e+00 rho_L 1.000000e+00 p_L 1.000000e+00 c_s_L 1.290994e+00
//RIEMMAN prefun R f_r 8.599751e-17 f_rd 7.745967e-01 pold 1.000000e+00 rho_R 1.000000e+00 p_R 1.000000e+00 c_s_R 1.290994e+00
//RIEMMAN s 0.000000e+00 pm 1.000000e+00 um 4.299875e-17 rho_s 1.000000e+00 u_s 4.299875e-17 p_s 1.000000e+00 gamma 1.666667e+00

}

void RiemannProblem::sample_riemann(double s, double pm, double um, double *rho_s, double *u_s, double *p_s)
{
	// Purpose: to sample the solution throughout the wave pattern.
	// Pressure pm and velocity um in the Star Region are known.
	// Sampling is performed in terms of the `speed' s = x/t.
	// Sampled values are rho_R, u_s, and p_s;

	double shl, sl, cml, pml, stl;
	double shr, sr, cmr, pmr, str;
	double c_s;


	if(s<=um)
	{
		//Sampling point lies to the left of the contact discontinuity

		if(pm<=r.p_L)
		{
			//Left rarefaction

			shl = r.u_L - r.c_sound_L;

			if(s<=shl)
			{
				//Sampled point is left data state

				*rho_s = r.rho_L;
				*u_s   = r.u_L;
				*p_s   = r.p_L;

#ifdef DEBUG_TORO_RIEMANN		
				printf("case A: Sampled point is left data state\n");
				fflush(stdout);
#endif
			}else{
				cml = r.c_sound_L*pow(pm/r.p_L,r.g1);

				stl = um - cml;

#ifdef DEBUG_TORO_RIEMANN		
				printf("u_exp_L_head % e u_exp_L_tail % e \n",shl,stl);
				printf("u_contact    % e\n",um);
#endif

				if(s>stl)
				{
					//Sampled point is Star Left state

					*rho_s = r.rho_L*pow(pm/r.p_L,1./r.gamma);

					*u_s   = um;
					*p_s   = pm;
				
#ifdef DEBUG_TORO_RIEMANN		
					printf("case B: Sampled point is Star Left state uL=%e uL*=%e, stl=%e\n",r.u_L,*u_s,stl);
					
#endif
				}else{	
					//Sampled point is inside left fan

					*u_s   = r.g5*( r.c_sound_L + r.g7* r.u_L + s);
					 c_s   = r.g5*( r.c_sound_L + r.g7*(r.u_L - s));

					*rho_s = r.rho_L*pow(c_s/r.c_sound_L,r.g4);
					*p_s   = r.p_L  *pow(c_s/r.c_sound_L,r.g3);
#ifdef DEBUG_TORO_RIEMANN		
					printf("case C: Sampled point is inside left fan\n");
					fflush(stdout);
#endif
				}

			}
		}else{

			//Left shock

			pml = pm / r.p_L;

			sl  = r.u_L - r.c_sound_L*sqrt(r.g2*pml + r.g1);

			if(s<=sl)
			{
				//Sampled point is the left data state

				*rho_s = r.rho_L;
				*u_s   = r.u_L;
				*p_s   = r.p_L;

#ifdef DEBUG_TORO_RIEMANN		
				printf("case D: Sampled point is the left data state\n");
				fflush(stdout);
#endif
			}else{

				//Sampled point is the Star Left state
			
				*rho_s = r.rho_L*(pml + r.g6)/(pml*r.g6 + 1.);
				*u_s   = um;
				*p_s   = pm;

#ifdef DEBUG_TORO_RIEMANN		
				printf("case E: Sampled point is the Star Left state\n");
				fflush(stdout);
#endif
			}
		}
	}else{

		//Sampling point lies to the right of the contact discontinuity


		if(pm>r.p_R)
		{

			//Right shock

			pmr = pm/r.p_R;

			sr = r.u_R + r.c_sound_R*sqrt(r.g2*pmr + r.g1);

			if(s>=sr)
			{
				//Sampled point is the right data state

				*rho_s = r.rho_R;
				*u_s   = r.u_R;
				*p_s   = r.p_R;

#ifdef DEBUG_TORO_RIEMANN		
				printf("case F: Sampled point is the right data state\n");
				fflush(stdout);
#endif
			}else{

				//Sampled point is Star Right state

				*rho_s = r.rho_R*(pmr + r.g6)/(pmr*r.g6 + 1.);

				*u_s   = um;
				*p_s   = pm;

#ifdef DEBUG_TORO_RIEMANN		
				printf("case G: Sampled point is Star Right state\n");
				fflush(stdout);
#endif
			}

		}else{

			//Right rarefaction

			shr = r.u_R + r.c_sound_R;


			if(s>=shr)
			{
				//Sampled point is the right data state
			
				*rho_s = r.rho_R;
				*u_s   = r.u_R;
				*p_s   = r.p_R;
#ifdef DEBUG_TORO_RIEMANN		
					printf("case H: Sampled point is the right data state\n");
					fflush(stdout);
#endif
			}else{

				cmr = r.c_sound_R*pow(pm/r.p_R,r.g1);
				str = um + cmr;

#ifdef DEBUG_TORO_RIEMANN		
				printf("u_exp_R_head %e u_exp_R_tail %e \n",shr,str);
#endif
				if(s<=str)
				{
					//Sampled point is the Star Right data

					*rho_s = r.rho_R*pow(pm/r.p_R,1./r.gamma);
					*u_s   = um;
					*p_s   = pm;

#ifdef DEBUG_TORO_RIEMANN		
					printf("case I: Sampled point is the Star Right data\n");
					fflush(stdout);
#endif
				}else{
					//Sampled point is inside left fan
	
					*u_s   = r.g5*( -r.c_sound_R + r.g7* r.u_R + s );
					 c_s   = r.g5*(  r.c_sound_R - r.g7*(r.u_R - s));

					*rho_s = r.rho_R*pow(c_s/r.c_sound_R, r.g4);
					*p_s   = r.p_R  *pow(c_s/r.c_sound_R, r.g3);

#ifdef DEBUG_TORO_RIEMANN		
					printf("case J: Sampled point is inside right fan\n");
					fflush(stdout);
#endif
				}
			}

		}

	}

	//done!
}
void RiemannProblem::Test_Problem_Toro_1(void)
{
	//problem 1
	//rho_*  0.426319 u_*  0.927453   p_*  0.303130
	double rho_L = 1.0;
	double u_L   = 0.0;
	double p_L   = 1.0;

	double rho_R = 0.125;
	double u_R   = 0.0;
	double p_R   = 0.1;

	double rho_s;
	double u_s;
	double p_s;

	double gamma_R = 1.4;
	double gamma_L = 1.4;


	double *stl;
	double *str;
	double *sta;

	int nst = 5;

	double s;

	stl = calloc_double_array(nst);
	str = calloc_double_array(nst);
	sta = calloc_double_array(nst);

	stl[0] = rho_L;
	stl[1] = u_L;
	stl[2] = p_L;
	stl[4] = gamma_L;

	str[0] = rho_R;
	str[1] = u_R;
	str[2] = p_R;
	str[4] = gamma_R;

	s = 0.5*(u_L + u_R);

	riemann(s,stl,str,sta);

	s = sta[1] - 1.0e-6;
	sample_riemann(s,sta[2],sta[1],&rho_s,&u_s,&p_s);

	printf("********************************************\n");
	printf("********************************************\n");
	printf("PROBLEM 1:\n");
	printf("Initial States:\n");
	printf("rho_L % f\tu_L % f\tp_L   % f\n",rho_L,u_L,p_L);
	printf("rho_R % f\tu_R % f\tp_R   % f\n",rho_R,u_R,p_R);
	printf("\n\n");
	printf("Answer:\n");
	printf("p_*   % f\tu_* % f\trho_L* % f\n",p_s,u_s,rho_s);
	printf("********************************************\n");



	free(stl);
	free(str);
	free(sta);
}
void RiemannProblem::Test_Problem_Toro_2(void)
{
	//problem 2
	//rho_*  0.021852 u_*  0.000000   p_*  0.001894
	double rho_L =  1.0;
	double u_L   = -2.0;
	double p_L   =  0.4;

	double rho_R = 1.0;
	double u_R   = 2.0;
	double p_R   = 0.4;

	double gamma_R = 1.4;
	double gamma_L = 1.4;


	double *stl;
	double *str;
	double *sta;

	int nst = 5;

	double s;
	double rho_s;
	double u_s;
	double p_s;

	stl = calloc_double_array(nst);
	str = calloc_double_array(nst);
	sta = calloc_double_array(nst);

	stl[0] = rho_L;
	stl[1] = u_L;
	stl[2] = p_L;
	stl[4] = gamma_L;

	str[0] = rho_R;
	str[1] = u_R;
	str[2] = p_R;
	str[4] = gamma_R;

	s = 0.5*(u_L + u_R);

	riemann(s,stl,str,sta);

	s = sta[1] - 1.0e-6;
	sample_riemann(s,sta[2],sta[1],&rho_s,&u_s,&p_s);

	printf("********************************************\n");
	printf("********************************************\n");
	printf("PROBLEM 2:\n");
	printf("Initial States:\n");
	printf("rho_L % f\tu_L % f\tp_L   % f\n",rho_L,u_L,p_L);
	printf("rho_R % f\tu_R % f\tp_R   % f\n",rho_R,u_R,p_R);
	printf("\n\n");
	printf("Answer:\n");
	printf("p_*   % f\tu_* % f\trho_L* % f\n",p_s,u_s,rho_s);
	printf("********************************************\n");




	free(stl);
	free(str);
	free(sta);
}
void RiemannProblem::Test_Problem_Toro_3(void)
{
	//problem 3
	//rho_*  0.575062 u_*  19.597451  p_*  460.893787
	double rho_L =  1.0;
	double u_L   =  0.0;
	double p_L   =  1000.0;

	double rho_R = 1.0;
	double u_R   = 0.0;
	double p_R   = 0.01;

	double gamma_R = 1.4;
	double gamma_L = 1.4;


	double *stl;
	double *str;
	double *sta;

	int nst = 5;

	double s;
	double rho_s;
	double u_s;
	double p_s;

	stl = calloc_double_array(nst);
	str = calloc_double_array(nst);
	sta = calloc_double_array(nst);

	stl[0] = rho_L;
	stl[1] = u_L;
	stl[2] = p_L;
	stl[4] = gamma_L;

	str[0] = rho_R;
	str[1] = u_R;
	str[2] = p_R;
	str[4] = gamma_R;

	s = 0.5*(u_L + u_R);

	riemann(s,stl,str,sta);

	s = sta[1] - 1.0e-6;
	sample_riemann(s,sta[2],sta[1],&rho_s,&u_s,&p_s);

	printf("********************************************\n");
	printf("********************************************\n");
	printf("PROBLEM 3:\n");
	printf("Initial States:\n");
	printf("rho_L % f\tu_L % f\tp_L   % f\n",rho_L,u_L,p_L);
	printf("rho_R % f\tu_R % f\tp_R   % f\n",rho_R,u_R,p_R);
	printf("\n\n");
	printf("Answer:\n");
	printf("p_*   % f\tu_* % f\trho_L* % f\n",p_s,u_s,rho_s);
	printf("********************************************\n");



	free(stl);
	free(str);
	free(sta);
}
void RiemannProblem::Test_Problem_Toro_4(void)
{

	//problem 4
	//rho_*  5.992417 u_* -6.196328   p_*  46.095044
	double rho_L =  1.0;
	double u_L   =  0.0;
	double p_L   =  0.01;

	double rho_R = 1.0;
	double u_R   = 0.0;
	double p_R   = 100.0;

	double gamma_R = 1.4;
	double gamma_L = 1.4;


	double *stl;
	double *str;
	double *sta;

	int nst = 5;

	double s;
	double rho_s;
	double p_s;
	double u_s;

	stl = calloc_double_array(nst);
	str = calloc_double_array(nst);
	sta = calloc_double_array(nst);

	stl[0] = rho_L;
	stl[1] = u_L;
	stl[2] = p_L;
	stl[4] = gamma_L;

	str[0] = rho_R;
	str[1] = u_R;
	str[2] = p_R;
	str[4] = gamma_R;

	s = 0.5*(u_L + u_R);

	riemann(s,stl,str,sta);

	s = sta[1] - 1.0e-6;
	sample_riemann(s,sta[2],sta[1],&rho_s,&u_s,&p_s);

	printf("********************************************\n");
	printf("********************************************\n");
	printf("PROBLEM 4:\n");
	printf("Initial States:\n");
	printf("rho_L % f\tu_L % f\tp_L   % f\n",rho_L,u_L,p_L);
	printf("rho_R % f\tu_R % f\tp_R   % f\n",rho_R,u_R,p_R);
	printf("\n\n");
	printf("Answer:\n");
	printf("p_*   % f\tu_* % f\trho_L* % f\n",p_s,u_s,rho_s);
	printf("********************************************\n");



	free(stl);
	free(str);
	free(sta);
}
void RiemannProblem::Test_Problem_Toro_5(void)
{
	//problem 5
	//rho_*  14.282350        u_*  8.689774   p_*  1691.646955
	double rho_L =  5.99924;
	double u_L   =  19.5975;
	double p_L   =  460.894;

	double rho_R = 5.99242;
	double u_R   = -6.19633;
	double p_R   = 46.0950;

	double gamma_R = 1.4;
	double gamma_L = 1.4;


	double *stl;
	double *str;
	double *sta;

	int nst = 5;

	double s;
	double rho_s;
	double p_s;
	double u_s;

	stl = calloc_double_array(nst);
	str = calloc_double_array(nst);
	sta = calloc_double_array(nst);

	stl[0] = rho_L;
	stl[1] = u_L;
	stl[2] = p_L;
	stl[4] = gamma_L;

	str[0] = rho_R;
	str[1] = u_R;
	str[2] = p_R;
	str[4] = gamma_R;

	s = 0.5*(u_L + u_R);
	riemann(s,stl,str,sta);

	
	s = sta[1] - 1.0e-6;
	sample_riemann(s,sta[2],sta[1],&rho_s,&u_s,&p_s);

	printf("********************************************\n");
	printf("********************************************\n");
	printf("PROBLEM 5:\n");
	printf("Initial States:\n");
	printf("rho_L % f\tu_L % f\tp_L   % f\n",rho_L,u_L,p_L);
	printf("rho_R % f\tu_R % f\tp_R   % f\n",rho_R,u_R,p_R);
	printf("\n\n");
	printf("Answer:\n");
	printf("p_*   % f\tu_* % f\trho_L* % f\n",p_s,u_s,rho_s);
	printf("********************************************\n");


	free(stl);
	free(str);
	free(sta);
}
